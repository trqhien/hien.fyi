[{"content":"The Scenario Tired of using if let to unwrap optional value inside a SwiftUI View that doesnâ€™t feel natural?\nstruct ContentView: View { @Binding var error: String? var body: some View { ... if let text { Text(text) } } } The Solution Create a generic view that wraps around if let\nstruct IfLet\u0026lt;Data, Content\u0026gt;: View where Content: View { let data: Data? let content: (Data) -\u0026gt; Content init( data: Data?, @ViewBuilder content: @escaping (Data) -\u0026gt; Content ) { self.data = data self.content = content } var body: some View { if let data { content(data) } } } The Usage struct ContentView: View { @Binding var error: String? var body: some View { ... IfLet(data: error) { Text($0) } } } ","permalink":"http://localhost:1313/snippets/if-let-view/","summary":"Creating a view that unwraps an optional value intended to be consumed by its child","title":"IfLet View"},{"content":"The problem Enums, along with classes and structs, play a crucial role in structuring your Swift code, allowing you to define data models and behaviors in a clean, organized, and type-safe manner. However, enums, perhaps Appleâ€™s least favorite child, still havenâ€™t received the attention they deserve. Compared to their siblings, enums lack some great features that structs and classes get for free.\nOne particular feature that we\u0026rsquo;ll focus on today is KeyPath, a powerful feature that only available for struct and class. Every field on struct or class gets a free key path denoted by a backslash syntax\nstruct Employee { let name: String var age: Int var address: Address } struct Address { var city: String var country: String } \\Employee.name\\ // KeyPath\u0026lt;Employee, String\u0026gt; \\Employee.address.city // WritableKeyPath\u0026lt;User, Int\u0026gt; let employee = Employee(name: \u0026#34;Blob\u0026#34;, age: 28, address: Address(city: \u0026#34;Ho Chi Minh\u0026#34;, country: \u0026#34;Vietnam\u0026#34;)) employee[keyPath: \\.name] // Blob employee[keyPath: \\.address.city] = \u0026#34;Manila\u0026#34; Enums lack the ergonomic ability to drill down and access data. The Swift API provides only two ways to work with enums: switch and case let, both of which require a lot of boilerplate code just to access the associated data within an enum.\nenum SubscriptionType { case pro(renewal: Date) case free } var subsription: SubscriptionType ... if case let .pro(renewalDated) = subscription else { print(renewalDated) } // or switch subscription { case let .pro(renewalDated): print(renewalDated) default: break } The situation becomes even more cumbersome when dealing with nested enums. For example\nenum LoadingStatus { case idle case loading case loaded(SubscriptionType) case failure(Error) } Introducing CasePath So, is it possible for enums to have the same features as their siblings? Wouldn\u0026rsquo;t it be nice to do this instead of switch or case let ?\nsubscription[keyPath: \\.pro.renewalDate] loadingStatus[keyPath: \\.loaded.pro.renewalDate] While researching this problem, I came across the swift-case-paths package developed by the PointFree team and instantly fell in love with it. Iâ€™ve been using it in all my projects ever since. So the PointFree team introduced a new concept called CasePath. Simply put, case paths are key paths, but for enums.\nAll you have to do is to annotate your enum with @CasePathable macro. The Swift Syntax will generate the necessary boilerplate that allows you to drill down to an enumâ€™s associated type as if it were a key path.\n@CasePathable enum SubscriptionType { ... } @CasePathable enum LoadingStatus { ... } var loadingStatus = LoadingStatus.loaded(.pro(renewal: Date(...))) loadingStatuss[case: \\.loaded.pro] // Date? You can also do case matching\nlet subscription = SubscriptionType.free subscription.is(\\.free) // true subscription.is(\\.pro) // false Or mutate the associated value\nfunc renewPro() { subscription.modify(\\.pro) { $0.addTimeInterval(365 * 24 * 60 * 60) } } Struct dot chaining syntax for enum Recall how easy it is to access the data inside a struct or class using the dot syntax.\nemployee.name employee.address.country CasePath has you coveredâ€”you can use @CasePathable together with @dynamicMemberLookup to enable dot-chaining syntax for enums. How neat! ðŸ™Œ\nstruct User { let username: String let subscriptionType: SubscriptionType } @CasePathable @dynamicMemberLookup enum SubscriptionType { ... } let blob = User(username: \u0026#34;Blob\u0026#34;, subscriptionType: .free) let klob = User(username: \u0026#34;Klob\u0026#34;, subscriptionType: .pro(renewal: Date(...)) blob.subscriptionType.pro // nil blob.subscriptionType.pro // Date(...) Moreover, this also enables key path expressions for enum case. Now it can be use in function that accepts key path\nlet users: [User] = [...] let renewalDates = users.compactMap(\\.subscriptionType.pro) // [Date] let renewalDates = users.map(\\.subscriptionType.pro) // [Date?] Final words CasePath unlocks even more power from enums. The PointFree team has been leveraging CasePath in their other open-source projects, such as Composable Architecture and SwiftUI Navigation. It greatly helps in making our code more readable and ergonomic. This article just scratches the surface. Since Iâ€™ve been intensively using CasePath in many of my projects, Iâ€™ve created a lot of utilities around it. Weâ€™ll discuss this more in a future article.\n","permalink":"http://localhost:1313/posts/unlocking-more-power-from-enums-with-casepath/","summary":"Adding key path and dynamic lookup support for enum with swift-case-paths","title":"Unlocking more power from enums with CasePath"}]